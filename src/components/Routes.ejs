import { h } from 'preact';
import { observable, asMap, transaction, autorun } from 'mobx';
import { connect } from 'mobx-preact';

import PagePreloader from './PagePreloader';
import Component from './Component';
import Store from '../stores';

type FetchData = (store: Store, callback: (data: {}) => void) => void;

interface IPageModule {
  default: preact.ComponentConstructor<{}, {}>;
  fetchData: undefined | FetchData;
}

type AnyData = {} | null;

const required = {};
const pages = observable(asMap({} as { [key: string]: preact.ComponentConstructor<{}, {}> }));
const fetchers = observable(asMap({} as { [key: string]: FetchData }));
const fetcher = observable({
  data: null as AnyData,
  path: ''
});

function fetchDataStub(_: any, callback: (data: {}) => void): void {
  callback({});
}

declare function require(path: string): any;

declare namespace require {
  function ensure(deps: string[], callback: () => void): void;
}

function merge(matchResult: {}, data: {}) {
  const result = {};
  for (const key of Object.keys(matchResult)) {
    result[key] = matchResult[key];
  }
  for (const key of Object.keys(data)) {
    result[key] = data[key];
  }
  return result;
}

function match(path: string, pattern: string): {} | null {
  if (pattern.indexOf(':') === -1) {
    return path === pattern;
  }
  const pathChunks = path.split('/');
  const patternChunks = pattern.split('/');
  if (pathChunks.length !== patternChunks.length) {
    return null;
  }
  const result = {};
  for (let i = 0; i < pathChunks.length; i++) {
    if (patternChunks[i][0] === ':') {
      result[patternChunks[i].substr(1)] = pathChunks[i];
    } else if (patternChunks[i] !== pathChunks[i]) {
      return null;
    }
  }
  return result;
}

@connect
export default class Routes extends Component<{}, {}> {

  static enableFetcher(store: Store) {
    autorun(() => {
      const path = store.routing.path;
      <% routes.forEach(route => {%>
      if (match(path, <%- route.path %>)) {
        if (!pages.has(<%- route.page %>)) {
          if (!required[<%- route.page %>]) {
            require.ensure([<%- route.page %>], () => {
              const mod = require(<%- route.page %>) as IPageModule;
              transaction(() => {
                pages.set(<%- route.page %>, mod.default);
                fetchers.set(<%- route.page %>, mod.fetchData || fetchDataStub);
              });
            });
          }
        }
        if (fetchers.has(<%- route.page %>) && fetcher.path !== path) {
          transaction(() => {
            fetcher.data = null;
            fetcher.path = path;
          });
          fetchers.get(<%- route.page %>)(store, (data: {}) => {
            if (fetcher.path === path) {
              fetcher.data = data;
            }
          });
        }
      }
      <% }) %>
    });
  }

  render() {
    const path = this.store.routing.path;
    let result = null as {} | null;
    <% routes.forEach(route => { %>
    result = match(path, <%- route.path %>);
    if (result) {
      if (pages.has(<%- route.page %>) && fetcher.path === path && fetcher.data) {
        return h(pages.get(<%- route.page %>), merge(result, fetcher.data));
      }
      return <PagePreloader />;
    }
    <% }) %>
    return <div>not found</div>;
  }

}
